# ℹ️ Since the database was set up separately from the app,
# the contents of the model classes were largely autogenerated by the command
# `sqlacodegen --generator sqlmodels postgresql://localhost:5432/postgres`

from typing import List, ClassVar, Optional
from datetime import datetime, timezone

from pydantic import Json
from sqlmodel import Field, SQLModel, Relationship
from sqlalchemy import (
    CHAR,
    Enum,
    Text,
    String,
    Boolean,
    Integer,
    DateTime,
    BigInteger,
    SmallInteger,
    UniqueConstraint,
    ForeignKeyConstraint,
    PrimaryKeyConstraint,
)
from sqlalchemy.schema import Column
from sqlalchemy.dialects.postgresql import JSONB, insert


class BaseModel(SQLModel):
    """Represents the base class for all models."""

    # Specifies the set of index elements which represent the ON CONFLICT target
    UPSERT_INDEX_ELEMENTS: ClassVar[set[str]] = set()

    # Specifies the set of fields to exclude from updating in the resulting
    # UPSERT statement
    UPSERT_EXCLUDE_FIELDS: ClassVar[set[str]] = set()

    @property
    def primary_key(self):
        return [k for k, v in self.model_fields.items() if v.primary_key][0]

    def upsert(self):
        # Shoutout this guy: https://github.com/fastapi/sqlmodel/issues/59#issuecomment-2085514089
        """Returns an UPSERT statement"""
        exclude_fields = self.UPSERT_EXCLUDE_FIELDS.copy()

        # Dump the model and exclude the specified fields during update.
        obj_dict = self.model_dump(exclude={self.primary_key})
        to_update = obj_dict.copy()
        for field in exclude_fields:
            _ = to_update.pop(field, None)

        stmt = insert(self.__class__).values(obj_dict)
        stmt = stmt.on_conflict_do_update(
            index_elements=self.UPSERT_INDEX_ELEMENTS,
            set_=to_update,
        )

        return stmt

    @classmethod
    def bulk_insert_ignore_conflicts(cls, model_instances: list[SQLModel]):
        insertables = []

        for obj in model_instances:
            insertables.append(obj.model_dump(exclude={obj.primary_key}))
            if not isinstance(obj, cls):
                raise ValueError("Can only bulk insert into one model at a time")

        return insert(cls).values(insertables).on_conflict_do_nothing()


class Title(BaseModel, table=True):
    __tablename__ = "titles"
    __table_args__ = (
        PrimaryKeyConstraint("id", name="titles_pkey"),
        UniqueConstraint("netflix_id", name="netflix_id"),
    )

    id: Optional[int] = Field(
        default=None, sa_column=Column("id", Integer, primary_key=True)
    )
    netflix_id: int = Field(default=None, sa_column=Column("netflix_id", BigInteger))
    title: Optional[str] = Field(default=None, sa_column=Column("title", String(256)))
    content_type: Optional[str] = Field(
        default=None,
        sa_column=Column(
            "content_type", Enum("movie", "tv series", name="content_type")
        ),
    )
    release_year: Optional[int] = Field(
        default=None, sa_column=Column("release_year", Integer)
    )
    runtime: Optional[int] = Field(default=None, sa_column=Column("runtime", Integer))
    meta_data: Optional[Json] = Field(default=None, sa_column=Column("metadata", JSONB))

    availability: List["Availability"] = Relationship(back_populates="title")
    ratings: List["Rating"] = Relationship(back_populates="title")


class Availability(BaseModel, table=True):
    __table_args__ = (
        ForeignKeyConstraint(
            ["netflix_id"], ["titles.netflix_id"], name="availability_netflix_id_fkey"
        ),
        PrimaryKeyConstraint("id", name="availability_pkey"),
        UniqueConstraint("country", "netflix_id", name="unique_country_and_netflix_id"),
    )

    id: Optional[int] = Field(
        default=None, sa_column=Column("id", Integer, primary_key=True)
    )
    netflix_id: int = Field(default=None, sa_column=Column("netflix_id", BigInteger))
    redirected_netflix_id: Optional[int] = Field(
        default=None, sa_column=Column("redirected_netflix_id", BigInteger)
    )
    country: str = Field(default=None, sa_column=Column("country", CHAR(2)))
    titlepage_reachable: Optional[bool] = Field(
        default=None, sa_column=Column("titlepage_reachable", Boolean)
    )
    available: Optional[bool] = Field(
        default=None, sa_column=Column("available", Boolean)
    )
    checked_at: Optional[datetime] = Field(
        default=datetime.now(timezone.utc), sa_column=Column("checked_at", DateTime)
    )

    title: Title = Relationship(back_populates="availability")


class Rating(BaseModel, table=True):
    __tablename__ = "ratings"
    __table_args__ = (
        ForeignKeyConstraint(
            ["netflix_id"], ["titles.netflix_id"], name="ratings_netflix_id_fkey"
        ),
        PrimaryKeyConstraint("id", name="ratings_pkey"),
        UniqueConstraint("vendor", "netflix_id", name="unique_vendor_and_netflix_id"),
    )

    id: Optional[int] = Field(
        default=None, sa_column=Column("id", Integer, primary_key=True)
    )
    netflix_id: int = Field(default=None, sa_column=Column("netflix_id", BigInteger))
    vendor: str = Field(default=None, sa_column=Column("vendor", String(32)))
    url: Optional[str] = Field(default=None, sa_column=Column("url", Text))
    rating: int = Field(default=None, sa_column=Column("rating", SmallInteger))
    ratings_count: Optional[int] = Field(
        default=None, sa_column=Column("ratings_count", Integer)
    )
    checked_at: Optional[datetime] = Field(
        default=datetime.now(timezone.utc), sa_column=Column("checked_at", DateTime)
    )

    title: Title = Relationship(back_populates="ratings")
